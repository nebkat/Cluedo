[1mdiff --git a/src/com/wolfetones/cluedo/board/BoardModel.java b/src/com/wolfetones/cluedo/board/BoardModel.java[m
[1mindex d7bbe47..ddfce0f 100644[m
[1m--- a/src/com/wolfetones/cluedo/board/BoardModel.java[m
[1m+++ b/src/com/wolfetones/cluedo/board/BoardModel.java[m
[36m@@ -238,7 +238,7 @@[m [mpublic class BoardModel {[m
                     System.out.print(":");[m
                 } else if (TILES[i][j] instanceof RoomTile) {[m
                     System.out.print("R");[m
[31m-                } else if (TILES[i][j] instanceof OccupyableTile) {[m
[32m+[m[32m                } else if (TILES[i][j] instanceof OccupiableTile) {[m
                     System.out.print("=");[m
                 }[m
             }[m
[1mdiff --git a/src/com/wolfetones/cluedo/board/PathFinder.java b/src/com/wolfetones/cluedo/board/PathFinder.java[m
[1mindex f10419d..02c6a98 100644[m
[1m--- a/src/com/wolfetones/cluedo/board/PathFinder.java[m
[1m+++ b/src/com/wolfetones/cluedo/board/PathFinder.java[m
[36m@@ -1,6 +1,6 @@[m
 package com.wolfetones.cluedo.board;[m
 [m
[31m-import com.wolfetones.cluedo.board.tiles.OccupyableTile;[m
[32m+[m[32mimport com.wolfetones.cluedo.board.tiles.OccupiableTile;[m
 import com.wolfetones.cluedo.board.tiles.Tile;[m
 [m
 import java.util.*;[m
[36m@@ -10,40 +10,83 @@[m [mpublic class PathFinder {[m
         return Math.abs(a.getX() - b.getX()) + Math.abs(a.getY() - b.getY());[m
     }[m
 [m
[31m-    public static List<Tile> findQuickestPath(Tile start, Tile target, int moves) {[m
[31m-        if (tileManhattanDistance(start, target) > moves) {[m
[32m+[m[32m    private static int expectedMovesForNode(Node node, Tile target) {[m
[32m+[m[32m        return node.path.size() + tileManhattanDistance(node.tile, target);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    public static List<Tile> findQuickestPath(Tile start, Tile target, int maxMoves) {[m
[32m+[m[32m        // If tiles are too distant by manhattan route a path is not possible[m
[32m+[m[32m        if (tileManhattanDistance(start, target) > maxMoves) {[m
             return null;[m
         }[m
 [m
[31m-        PriorityQueue<Node> queue = new PriorityQueue<>((a, b) -> {[m
[31m-            int fA = a.path.size() + tileManhattanDistance(a.tile, target);[m
[31m-            int fB = b.path.size() + tileManhattanDistance(b.tile, target);[m
[32m+[m[32m        // Priority queue to hold further explorable tiles[m
[32m+[m[32m        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingInt(a -> expectedMovesForNode(a, target)));[m
 [m
[31m-            return fA - fB;[m
[31m-        });[m
[32m+[m[32m        // Map of tiles to nodes holding their shortest paths[m
         Map<Tile, Node> nodes = new HashMap<>();[m
 [m
[32m+[m[32m        // Add the first[m
         queue.add(new Node(start, Collections.singletonList(start)));[m
 [m
[31m-        while (!nodes.containsKey(target) && queue.size() > 0) {[m
[32m+[m[32m        while (queue.size() > 0) {[m
             Node current = queue.poll();[m
[32m+[m
[32m+[m[32m            // If path has already exceeded max moves, don't check neighbours[m
[32m+[m[32m            if (expectedMovesForNode(current, target) >= maxMoves) continue;[m
[32m+[m
[32m+[m[32m            // Append current tile to the path[m
[32m+[m[32m            List<Tile> path = new ArrayList<>(current.path);[m
[32m+[m[32m            path.add(current.tile);[m
[32m+[m
[32m+[m[32m            // Loop through neighbours[m
             for (Tile t : current.tile.getNeighbours()) {[m
[31m-                if (!(t instanceof OccupyableTile)) continue;[m
[32m+[m[32m                // Only occupiable tiles can be traversed[m
[32m+[m[32m                if (!(t instanceof OccupiableTile)) continue;[m
[32m+[m
[32m+[m[32m                // Don't loop through existing tiles[m
                 if (current.path.contains(t)) continue;[m
[31m-                if (current.path.size() >= moves && t != target) continue;[m
 [m
[31m-                if (nodes.containsKey(t) && nodes.get(t).path.size() <= current.path.size()) continue;[m
[32m+[m[32m                Node node;[m
[32m+[m[32m                if (nodes.containsKey(t)) {[m
[32m+[m[32m                    // Existing node[m
[32m+[m[32m                    node = nodes.get(t);[m
 [m
[31m-                List<Tile> path = new ArrayList<>(current.path);[m
[31m-                path.add(t);[m
[31m-                Node node = new Node(t, path);[m
[32m+[m[32m                    // If tile already has node and path is shorter ignore long route[m
[32m+[m[32m                    if (node.path.size() <= current.path.size()) {[m
[32m+[m[32m                        continue;[m
[32m+[m[32m                    }[m
 [m
[31m-                queue.add(node);[m
[31m-                nodes.put(t, node);[m
[32m+[m[32m                    // Old path was longer, replace with new path[m
[32m+[m[32m                    node.path = path;[m
[32m+[m[32m                } else {[m
[32m+[m[32m                    // New node[m
[32m+[m[32m                    node = new Node(t, path);[m
[32m+[m
[32m+[m[32m                    nodes.put(t, node);[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                // Attempting to find target[m
[32m+[m[32m                if (t != target) {[m
[32m+[m[32m                    queue.add(node);[m
[32m+[m[32m                } else {[m
[32m+[m[32m                    // Max moves is now the shortest path length[m
[32m+[m[32m                    maxMoves = path.size();[m
[32m+[m
[32m+[m[32m                    // If target has been found no need to check neighbours further[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
             }[m
         }[m
 [m
[31m-        return nodes.containsKey(target) ? nodes.get(target).path : null;[m
[32m+[m[32m        // If path to target was found return[m
[32m+[m[32m        if (nodes.containsKey(target)) {[m
[32m+[m[32m            List<Tile> path = nodes.get(target).path;[m
[32m+[m[32m            path.add(target);[m
[32m+[m[32m            return path;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        return null;[m
     }[m
 [m
     private static class Node {[m
[1mdiff --git a/src/com/wolfetones/cluedo/board/tiles/CorridorTile.java b/src/com/wolfetones/cluedo/board/tiles/CorridorTile.java[m
[1mindex f14bf5f..342a780 100644[m
[1m--- a/src/com/wolfetones/cluedo/board/tiles/CorridorTile.java[m
[1m+++ b/src/com/wolfetones/cluedo/board/tiles/CorridorTile.java[m
[36m@@ -2,7 +2,7 @@[m [mpackage com.wolfetones.cluedo.board.tiles;[m
 [m
 import com.wolfetones.cluedo.card.Room;[m
 [m
[31m-public class CorridorTile extends OccupyableTile {[m
[32m+[m[32mpublic class CorridorTile extends OccupiableTile {[m
     private Room mAdjacentRoom = null;[m
 [m
     public CorridorTile(int x, int y) {[m
[1mdiff --git a/src/com/wolfetones/cluedo/board/tiles/OccupyableTile.java b/src/com/wolfetones/cluedo/board/tiles/OccupyableTile.java[m
[1mdeleted file mode 100644[m
[1mindex d450da3..0000000[m
[1m--- a/src/com/wolfetones/cluedo/board/tiles/OccupyableTile.java[m
[1m+++ /dev/null[m
[36m@@ -1,19 +0,0 @@[m
[31m-package com.wolfetones.cluedo.board.tiles;[m
[31m-[m
[31m-import com.wolfetones.cluedo.game.Player;[m
[31m-[m
[31m-public abstract class OccupyableTile extends Tile {[m
[31m-    protected Player mPlayer = null;[m
[31m-[m
[31m-    public OccupyableTile(int x, int y) {[m
[31m-        super(x, y);[m
[31m-    }[m
[31m-[m
[31m-    public void setPlayer(Player player) {[m
[31m-        mPlayer = player;[m
[31m-    }[m
[31m-[m
[31m-    public boolean isOccupied() {[m
[31m-        return mPlayer != null;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/com/wolfetones/cluedo/board/tiles/StartTile.java b/src/com/wolfetones/cluedo/board/tiles/StartTile.java[m
[1mindex 8c43ea2..89ff994 100644[m
[1m--- a/src/com/wolfetones/cluedo/board/tiles/StartTile.java[m
[1m+++ b/src/com/wolfetones/cluedo/board/tiles/StartTile.java[m
[36m@@ -2,7 +2,7 @@[m [mpackage com.wolfetones.cluedo.board.tiles;[m
 [m
 import com.wolfetones.cluedo.card.Suspect;[m
 [m
[31m-public class StartTile extends OccupyableTile {[m
[32m+[m[32mpublic class StartTile extends OccupiableTile {[m
     private Suspect mStartingSuspect;[m
 [m
     public StartTile(int x, int y, Suspect startingSuspect) {[m
